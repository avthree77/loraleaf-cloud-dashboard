<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Dashboard | LoRaLeaf Sensor Network</title>

    <!-- Main Site Styles -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>

    <!-- Main Site Scripts -->
    <script src="/js/main.js"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
        }

        .dashboard-container {
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        /* Top Grid: Barometer + Map */
        .top-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        /* Barometer Hero */
        .barometer-hero {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .barometer-label {
            font-size: 28px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .barometer-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .barometer-dial {
            position: relative;
            width: 300px;
            height: 300px;
        }

        .barometer-info {
            text-align: left;
            max-width: 300px;
        }

        .pressure-reading {
            font-size: 48px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }

        .pressure-unit {
            font-size: 20px;
            color: #999;
            font-weight: normal;
        }

        .trend-indicator {
            font-size: 18px;
            margin: 15px 0;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
        }

        .trend-rising {
            background: #dcfce7;
            color: #166534;
        }

        .trend-falling {
            background: #fee2e2;
            color: #991b1b;
        }

        .trend-stable {
            background: #e0e7ff;
            color: #3730a3;
        }

        .condition-text {
            font-size: 16px;
            color: #666;
            line-height: 1.6;
        }

        #barometer-needle {
            opacity: 0;
            transition: opacity 0.3s ease-in;
        }

        #barometer-needle.visible {
            opacity: 1;
        }

        /* Map Container */
        .map-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .map-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .map-title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .map-btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin-left: 10px;
        }

        .map-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        #map {
            height: 450px;
            border-radius: 10px;
        }

        /* Traffic Light Alert System */
        .alerts-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .alert-box {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .alert-box:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.3);
        }

        .alert-box.now {
            border-top: 5px solid #dc2626;
        }

        .alert-box.soon {
            border-top: 5px solid #f59e0b;
        }

        .alert-box.later {
            border-top: 5px solid #10b981;
        }

        .alert-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .alert-title {
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .alert-title.now { color: #dc2626; }
        .alert-title.soon { color: #f59e0b; }
        .alert-title.later { color: #10b981; }

        .alert-count {
            font-size: 36px;
            font-weight: bold;
            opacity: 0.3;
        }

        .alert-count.now { color: #dc2626; }
        .alert-count.soon { color: #f59e0b; }
        .alert-count.later { color: #10b981; }

        .alert-summary {
            font-size: 14px;
            color: #666;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .alert-items {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .alert-box.expanded .alert-items {
            max-height: 500px;
            transition: max-height 0.5s ease-in;
        }

        .alert-item {
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .alert-item.now {
            background: #fee2e2;
            border-left: 4px solid #dc2626;
        }

        .alert-item.soon {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
        }

        .alert-item.later {
            background: #d1fae5;
            border-left: 4px solid #10b981;
        }

        .alert-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .alert-text {
            flex: 1;
        }

        .alert-text strong {
            display: block;
            margin-bottom: 3px;
        }

        .alert-expand-hint {
            text-align: center;
            font-size: 12px;
            color: #999;
            margin-top: 10px;
            font-style: italic;
        }

        /* Charts */
        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .chart-title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }

        .time-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .time-btn {
            padding: 8px 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .time-btn:hover, .time-btn.active {
            background: #667eea;
            color: white;
        }

        /* Node Cards */
        .nodes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .node-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .node-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.3);
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .node-name {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .node-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-active {
            background: #4ade80;
            color: white;
        }

        .status-inactive {
            background: #f87171;
            color: white;
        }

        .reading {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .reading:last-child {
            border-bottom: none;
        }

        .reading-label {
            color: #666;
            font-size: 14px;
        }

        .reading-value {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }

        .temp { color: #f59e0b; }
        .pressure { color: #3b82f6; }
        .humidity { color: #06b6d4; }

        .timestamp {
            text-align: center;
            color: #999;
            font-size: 12px;
            margin-top: 15px;
        }

        /* Average Readings */
        .average-readings {
            margin-top: 25px;
            padding-top: 25px;
            border-top: 2px solid #f0f0f0;
        }

        .average-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .average-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .average-item {
            text-align: center;
            padding: 15px;
            background: #f9fafb;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
        }

        .average-label {
            display: block;
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }

        .average-value {
            display: block;
            font-size: 20px;
            font-weight: bold;
        }

        @media (max-width: 1200px) {
            .top-grid {
                grid-template-columns: 1fr;
            }

            .barometer-container {
                flex-direction: column;
            }

            .alerts-container {
                grid-template-columns: 1fr;
            }

            .average-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <img src="/images/loraleaf-logo.svg" alt="LoRaLeaf Logo" class="logo">
            </div>
            <div class="nav-links">
                <a href="/#features">Features</a>
                <a href="/#how-it-works">How It Works</a>
                <a href="/#use-cases">Use Cases</a>
                <a href="/packages">Packages</a>
                <a href="/live" class="btn-secondary">Live Data</a>
                <a href="mailto:info@loraleaf.com" class="btn-primary">Get in Touch</a>
            </div>
            <div class="mobile-menu-toggle" id="mobileMenuToggle">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <div class="dashboard-container">
        <h1>üì° LoRaLeaf Sensor Network</h1>

        <!-- Top Grid: Barometer + Map -->
        <div class="top-grid">
            <!-- Barometer -->
            <div class="barometer-hero">
                <div class="barometer-label">üå§Ô∏è Smart Barometer</div>
                <div class="barometer-container">
                    <div class="barometer-dial">
                        <svg viewBox="0 0 300 300" id="barometer-svg">
                            <defs>
                                <linearGradient id="fairGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                    <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#3b82f6;stop-opacity:1" />
                                </linearGradient>
                                <linearGradient id="changeGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                    <stop offset="0%" style="stop-color:#9ca3af;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#6b7280;stop-opacity:1" />
                                </linearGradient>
                                <linearGradient id="rainGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                    <stop offset="0%" style="stop-color:#fb923c;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#f97316;stop-opacity:1" />
                                </linearGradient>
                            </defs>

                            <circle cx="150" cy="150" r="120" fill="none" stroke="#e5e7eb" stroke-width="40" />

                            <path id="fair-zone" fill="none" stroke="url(#fairGradient)" stroke-width="40" />
                            <path id="change-zone" fill="none" stroke="url(#changeGradient)" stroke-width="40" />
                            <path id="rain-zone" fill="none" stroke="url(#rainGradient)" stroke-width="40" />

                            <circle cx="150" cy="150" r="70" fill="white" stroke="#667eea" stroke-width="3" />

                            <g id="barometer-needle">
                                <path d="M 150 80 L 156 150 L 150 156 L 144 150 Z" fill="#dc2626" stroke="#991b1b" stroke-width="1" />
                                <circle cx="150" cy="150" r="10" fill="#dc2626" stroke="#991b1b" stroke-width="2" />
                            </g>

                            <g id="scale-marks"></g>

                            <text x="150" y="190" text-anchor="middle" font-size="32" id="condition-icon">üå§Ô∏è</text>
                        </svg>
                    </div>

                    <div class="barometer-info">
                        <div class="pressure-reading">
                            <span id="pressure-value">--</span>
                            <span class="pressure-unit">hPa</span>
                        </div>

                        <div id="trend-display" class="trend-indicator trend-stable">
                            <span id="trend-icon">‚Üí</span>
                            <span id="trend-text">Stable</span>
                        </div>

                        <div class="condition-text" id="condition-description">
                            Loading barometer data...
                        </div>
                    </div>
                </div>

                <!-- Average Readings -->
                <div class="average-readings">
                    <div class="average-title">üìä Average (NODE_01 + NODE_02)</div>
                    <div class="average-grid">
                        <div class="average-item">
                            <span class="average-label">üå°Ô∏è Temperature</span>
                            <span class="average-value temp" id="avg-temp">--¬∞C</span>
                        </div>
                        <div class="average-item">
                            <span class="average-label">üíß Humidity</span>
                            <span class="average-value humidity" id="avg-humidity">--%</span>
                        </div>
                        <div class="average-item">
                            <span class="average-label">üîΩ Pressure</span>
                            <span class="average-value pressure" id="avg-pressure">-- hPa</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Map -->
            <div class="map-container">
                <div class="map-header">
                    <div class="map-title">üó∫Ô∏è Node Locations</div>
                    <div>
                        <button class="map-btn" id="heatMapToggle" onclick="toggleHeatMap()">üå°Ô∏è Heat Map</button>
                    </div>
                </div>
                <div id="map"></div>
            </div>
        </div>

        <!-- Traffic Light Alerts -->
        <div class="alerts-container">
            <div class="alert-box now" onclick="toggleAlert('now')">
                <div class="alert-header">
                    <div class="alert-title now">üî¥ NOW</div>
                    <div class="alert-count now" id="now-count">0</div>
                </div>
                <div class="alert-summary" id="now-summary">No critical alerts</div>
                <div class="alert-items" id="now-items"></div>
                <div class="alert-expand-hint">Click to expand</div>
            </div>

            <div class="alert-box soon" onclick="toggleAlert('soon')">
                <div class="alert-header">
                    <div class="alert-title soon">üü° SOON</div>
                    <div class="alert-count soon" id="soon-count">0</div>
                </div>
                <div class="alert-summary" id="soon-summary">No warnings</div>
                <div class="alert-items" id="soon-items"></div>
                <div class="alert-expand-hint">Click to expand</div>
            </div>

            <div class="alert-box later" onclick="toggleAlert('later')">
                <div class="alert-header">
                    <div class="alert-title later">üü¢ LATER</div>
                    <div class="alert-count later" id="later-count">0</div>
                </div>
                <div class="alert-summary" id="later-summary">All clear</div>
                <div class="alert-items" id="later-items"></div>
                <div class="alert-expand-hint">Click to expand</div>
            </div>
        </div>

        <!-- Charts -->
        <div class="chart-container">
            <div class="chart-title" id="chart-title">üìä Temperature & Dewpoint History</div>
            <div class="time-selector">
                <button class="time-btn" onclick="updateCharts('1h')">1 Hour</button>
                <button class="time-btn" onclick="updateCharts('6h')">6 Hours</button>
                <button class="time-btn active" onclick="updateCharts('24h')">24 Hours</button>
                <button class="time-btn" onclick="updateCharts('3d')">3 Days</button>
                <button class="time-btn" onclick="updateCharts('7d')">7 Days</button>
                <button class="time-btn" onclick="resetChartZoom()" style="margin-left: 10px; background: #f59e0b; border-color: #f59e0b; color: white;">üîç Reset Zoom</button>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: #666; font-size: 14px; margin-bottom: 8px; font-weight: 500;">üìà Data Type:</label>
                <div style="display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="radio" name="dataType" value="temperature" checked onchange="updateCharts(currentTimeRange)"> üå°Ô∏è Temperature
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="radio" name="dataType" value="humidity" onchange="updateCharts(currentTimeRange)"> üíß Humidity
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="radio" name="dataType" value="pressure" onchange="updateCharts(currentTimeRange)"> üîΩ Pressure
                    </label>
                </div>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: #666; font-size: 14px; margin-bottom: 8px; font-weight: 500;">üìç Show Nodes:</label>
                <div id="node-checkboxes" style="display: flex; gap: 15px; flex-wrap: wrap;"></div>
            </div>
            <div style="margin-bottom: 10px; padding: 8px; background: #f0f9ff; border-left: 3px solid #3b82f6; border-radius: 4px; font-size: 13px; color: #1e40af;">
                üí° <strong>Tip:</strong> Scroll wheel to zoom, Ctrl+drag to pan, double-click or use Reset Zoom button to reset view
            </div>
            <canvas id="tempChart"></canvas>
        </div>

        <!-- Node Cards -->
        <div class="nodes" id="nodes-container"></div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <!-- Leaflet Heat -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.js" crossorigin=""></script>

    <script>
        const API_URL = '/api/nodes';
        const HISTORY_API_URL = '/api/history';
        const REFRESH_INTERVAL = 30000;
        const INACTIVE_THRESHOLD = 300;

        const NODE_LOCATIONS = {
            'NODE_01': { lat: 50.2660, lng: -5.0527, name: 'Outdoor Sensor 1' },
            'NODE_02': { lat: 50.2665, lng: -5.0520, name: 'Outdoor Sensor 2' },
            'NODE_WIFI': { lat: 50.2670, lng: -5.0515, name: 'Solar WiFi Node' },
            'NODE_INDOORS': { lat: 50.2655, lng: -5.0530, name: 'Indoor Sensor' }
        };

        let map, heatLayer, tempChart;
        let currentNodes = [];
        let currentTimeRange = '24h';
        let pressureHistory = [];

        // Barometer Functions
        function mapPressureToAngle(pressure) {
            const minPressure = 980;
            const maxPressure = 1040;
            const minAngle = -135;
            const maxAngle = 135;
            return minAngle + (pressure - minPressure) * (maxAngle - minAngle) / (maxPressure - minPressure);
        }

        function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
            const angleInRadians = (angleInDegrees) * Math.PI / 180.0;
            return {
                x: centerX + (radius * Math.cos(angleInRadians)),
                y: centerY + (radius * Math.sin(angleInRadians))
            };
        }

        function describeArc(x, y, radius, startAngle, endAngle) {
            const start = polarToCartesian(x, y, radius, endAngle);
            const end = polarToCartesian(x, y, radius, startAngle);
            const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
            return ["M", start.x, start.y, "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y].join(" ");
        }

        function drawZone(id, startPressure, endPressure) {
            const start = mapPressureToAngle(startPressure);
            const end = mapPressureToAngle(endPressure);
            const path = describeArc(150, 150, 120, start, end);
            document.getElementById(id).setAttribute('d', path);
        }

        function initBarometer() {
            const scaleMarks = document.getElementById('scale-marks');
            for (let i = 980; i <= 1040; i += 10) {
                const angle = mapPressureToAngle(i);
                const rad = angle * Math.PI / 180;
                const x1 = 150 + 100 * Math.cos(rad);
                const y1 = 150 + 100 * Math.sin(rad);
                const x2 = 150 + 110 * Math.cos(rad);
                const y2 = 150 + 110 * Math.sin(rad);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#666');
                line.setAttribute('stroke-width', '2');
                scaleMarks.appendChild(line);

                if (i % 20 === 0) {
                    const tx = 150 + 85 * Math.cos(rad);
                    const ty = 150 + 85 * Math.sin(rad);
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', tx);
                    text.setAttribute('y', ty + 5);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '12');
                    text.setAttribute('fill', '#666');
                    text.textContent = i;
                    scaleMarks.appendChild(text);
                }
            }

            drawZone('fair-zone', 1020, 1040);
            drawZone('change-zone', 1000, 1020);
            drawZone('rain-zone', 980, 1000);

            const needle = document.getElementById('barometer-needle');
            const svg = document.getElementById('barometer-svg');
            const transform = svg.createSVGTransform();
            transform.setRotate(-45, 150, 150);
            needle.transform.baseVal.appendItem(transform);
            needle.classList.add('visible');
        }

        function updateBarometer(pressure) {
            document.getElementById('pressure-value').textContent = pressure.toFixed(1);

            const angle = mapPressureToAngle(pressure) + 90;
            const needle = document.getElementById('barometer-needle');
            const svg = document.getElementById('barometer-svg');
            const transform = svg.createSVGTransform();
            transform.setRotate(angle, 150, 150);
            needle.transform.baseVal.clear();
            needle.transform.baseVal.appendItem(transform);

            pressureHistory.push(pressure);
            if (pressureHistory.length > 10) pressureHistory.shift();

            let trend = 'stable', trendIcon = '‚Üí', trendText = 'Stable';
            if (pressureHistory.length >= 2) {
                const diff = pressure - pressureHistory[0];
                if (diff > 2) {
                    trend = 'rising';
                    trendIcon = '‚Üó';
                    trendText = `Rising (+${diff.toFixed(1)} hPa)`;
                } else if (diff < -2) {
                    trend = 'falling';
                    trendIcon = '‚Üò';
                    trendText = `Falling (${diff.toFixed(1)} hPa)`;
                }
            }

            const trendDisplay = document.getElementById('trend-display');
            trendDisplay.className = `trend-indicator trend-${trend}`;
            document.getElementById('trend-icon').textContent = trendIcon;
            document.getElementById('trend-text').textContent = trendText;

            const conditionIcon = document.getElementById('condition-icon');
            const conditionDesc = document.getElementById('condition-description');

            if (pressure < 1000) {
                conditionIcon.textContent = 'üåßÔ∏è';
                conditionDesc.textContent = 'Low pressure. Rain likely within 12-24 hours.';
            } else if (pressure < 1020) {
                conditionIcon.textContent = 'üå§Ô∏è';
                conditionDesc.textContent = 'Changing conditions. Monitor pressure trends.';
            } else {
                conditionIcon.textContent = '‚òÄÔ∏è';
                conditionDesc.textContent = 'High pressure. Fair weather expected.';
            }
        }

        // Map Functions - Using Pi4 GUI working code
        let markers = {};
        let heatMapMode = false;
        let heatMapCircles = [];
        let heatMapLegend = null;
        let sensorIcon; // Will be created after Leaflet loads

        // Initialize map - Same as Pi4 GUI
        function initMap() {
            map = L.map('map').setView([50.2660, -5.0527], 10);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(map);

            // Create sensor icon AFTER Leaflet is loaded
            sensorIcon = L.divIcon({
                className: 'custom-div-icon',
                html: "<div style='background-color:#667eea;width:30px;height:30px;border-radius:50%;border:3px solid white;box-shadow:0 2px 5px rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center;color:white;font-weight:bold;'>üì°</div>",
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });

            console.log('Map initialized successfully');
        }

        function updateMapMarkers(nodes) {
            if (!map) return;

            // Clear existing markers
            Object.values(markers).forEach(marker => map.removeLayer(marker));
            markers = {};

            // Add markers for nodes with locations
            nodes.forEach(node => {
                const location = NODE_LOCATIONS[node.node_id];
                if (location) {
                    const marker = L.marker([location.lat, location.lng], {icon: sensorIcon});

                    // Only add to map if NOT in heat map mode
                    if (!heatMapMode) {
                        marker.addTo(map);
                    }

                    // Enhanced popup with all sensor data
                    const popupContent = `
                        <div style="min-width:250px;padding:5px;">
                            <div style="text-align:center;font-size:18px;font-weight:bold;margin-bottom:10px;color:#667eea;">
                                ${node.node_id}
                            </div>
                            ${location.name ? `<div style="text-align:center;color:#666;margin-bottom:8px;"><strong>${location.name}</strong></div>` : ''}
                            <hr style="margin:10px 0;border:none;border-top:2px solid #f0f0f0;">
                            <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                                <div><strong>üå°Ô∏è Temp:</strong></div><div style="text-align:right;color:#f59e0b;">${node.temperature.toFixed(1)}¬∞C</div>
                                <div><strong>üíß Humidity:</strong></div><div style="text-align:right;color:#06b6d4;">${node.humidity.toFixed(1)}%</div>
                                <div><strong>üîΩ Pressure:</strong></div><div style="text-align:right;color:#3b82f6;">${node.pressure.toFixed(1)} hPa</div>
                                ${node.battery_voltage ? `
                                <div><strong>üîã Battery:</strong></div><div style="text-align:right;color:#10b981;">${node.battery_voltage.toFixed(2)}V (${node.battery_percent}%)</div>
                                ` : ''}
                                ${node.rssi ? `
                                <div><strong>üì∂ RSSI:</strong></div><div style="text-align:right;color:#8b5cf6;">${node.rssi} dBm</div>
                                <div><strong>üì° SNR:</strong></div><div style="text-align:right;color:#ec4899;">${node.snr.toFixed(1)} dB</div>
                                ` : ''}
                            </div>
                            <hr style="margin:10px 0;border:none;border-top:1px solid #f0f0f0;">
                            <div style="text-align:center;font-size:11px;color:#999;">
                                Last update: ${node.last_update}
                            </div>
                        </div>
                    `;
                    marker.bindPopup(popupContent);

                    markers[node.node_id] = marker;
                }
            });

            // If we have markers, fit the map to show them (only if not in heat map mode)
            if (!heatMapMode) {
                const markerArray = Object.values(markers);
                if (markerArray.length > 0) {
                    const group = L.featureGroup(markerArray);
                    map.fitBounds(group.getBounds().pad(0.2));
                }
            }
        }

        // Heat map helper functions from Pi4 GUI
        function temperatureToColor(temp) {
            const clampedTemp = Math.max(-20, Math.min(50, temp));

            if (clampedTemp <= 0) {
                const ratio = (clampedTemp + 20) / 20;
                return interpolateColor('#3B82F6', '#06B6D4', ratio);
            } else if (clampedTemp <= 15) {
                const ratio = clampedTemp / 15;
                return interpolateColor('#06B6D4', '#10B981', ratio);
            } else if (clampedTemp <= 25) {
                const ratio = (clampedTemp - 15) / 10;
                return interpolateColor('#10B981', '#F59E0B', ratio);
            } else if (clampedTemp <= 35) {
                const ratio = (clampedTemp - 25) / 10;
                return interpolateColor('#F59E0B', '#F97316', ratio);
            } else {
                const ratio = (clampedTemp - 35) / 15;
                return interpolateColor('#F97316', '#EF4444', ratio);
            }
        }

        function interpolateColor(color1, color2, ratio) {
            const hex = (c) => parseInt(c.substring(1), 16);
            const r1 = (hex(color1) >> 16) & 255;
            const g1 = (hex(color1) >> 8) & 255;
            const b1 = hex(color1) & 255;
            const r2 = (hex(color2) >> 16) & 255;
            const g2 = (hex(color2) >> 8) & 255;
            const b2 = hex(color2) & 255;

            const r = Math.round(r1 + (r2 - r1) * ratio);
            const g = Math.round(g1 + (g2 - g1) * ratio);
            const b = Math.round(b1 + (b2 - b1) * ratio);

            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000;
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        function createHeatMapCircles() {
            removeHeatMapCircles();

            const nodesWithLocations = currentNodes.filter(node =>
                NODE_LOCATIONS[node.node_id]
            );

            if (nodesWithLocations.length === 0) {
                return;
            }

            let radius = 500;

            if (nodesWithLocations.length === 2) {
                const loc1 = NODE_LOCATIONS[nodesWithLocations[0].node_id];
                const loc2 = NODE_LOCATIONS[nodesWithLocations[1].node_id];
                const distance = calculateDistance(loc1.lat, loc1.lng, loc2.lat, loc2.lng);
                radius = (distance / 2) * 1.1;
            } else if (nodesWithLocations.length > 2) {
                let minDistance = Infinity;
                for (let i = 0; i < nodesWithLocations.length; i++) {
                    for (let j = i + 1; j < nodesWithLocations.length; j++) {
                        const loc1 = NODE_LOCATIONS[nodesWithLocations[i].node_id];
                        const loc2 = NODE_LOCATIONS[nodesWithLocations[j].node_id];
                        const dist = calculateDistance(loc1.lat, loc1.lng, loc2.lat, loc2.lng);
                        minDistance = Math.min(minDistance, dist);
                    }
                }
                radius = (minDistance / 2) * 1.05;
            }

            nodesWithLocations.forEach(node => {
                const location = NODE_LOCATIONS[node.node_id];
                const color = temperatureToColor(node.temperature);

                const circle = L.circle([location.lat, location.lng], {
                    radius: radius,
                    fillColor: color,
                    fillOpacity: 0.4,
                    color: color,
                    weight: 2,
                    opacity: 0.6
                }).addTo(map);

                circle.bindPopup(`
                    <div style="text-align:center;padding:5px;">
                        <strong>${node.node_id}</strong><br>
                        <span style="font-size:20px;color:${color};">${node.temperature.toFixed(1)}¬∞C</span>
                    </div>
                `);

                heatMapCircles.push(circle);
            });
        }

        function removeHeatMapCircles() {
            heatMapCircles.forEach(circle => map.removeLayer(circle));
            heatMapCircles = [];
        }

        function toggleHeatMap() {
            if (!map) return;

            heatMapMode = !heatMapMode;
            const btn = document.getElementById('heatMapToggle');

            if (heatMapMode) {
                btn.textContent = 'üìç Normal View';

                Object.values(markers).forEach(marker => {
                    map.removeLayer(marker);
                });

                createHeatMapCircles();
            } else {
                btn.textContent = 'üå°Ô∏è Heat Map';

                removeHeatMapCircles();

                Object.values(markers).forEach(marker => {
                    map.addLayer(marker);
                });
            }
        }

        // Alert System
        function toggleAlert(category) {
            const box = document.querySelector(`.alert-box.${category}`);
            box.classList.toggle('expanded');
        }

        function calculateDewpoint(temp, humidity) {
            return temp - ((100 - humidity) / 5);
        }

        function analyzeAlerts(nodes) {
            const alerts = { now: [], soon: [], later: [] };

            const activeNodes = nodes.filter(n =>
                n.seconds_since_update < INACTIVE_THRESHOLD &&
                /^NODE_\d+$/.test(n.node_id)
            );

            const inactiveNodes = nodes.filter(n => n.seconds_since_update >= INACTIVE_THRESHOLD);

            activeNodes.forEach(node => {
                const dewpoint = calculateDewpoint(node.temperature, node.humidity);
                const dewpointGap = node.temperature - dewpoint;

                // Frost alerts
                if (node.temperature <= 0) {
                    alerts.now.push({
                        icon: '‚ùÑÔ∏è',
                        title: 'CRITICAL FROST',
                        text: `${node.node_id}: ${node.temperature.toFixed(1)}¬∞C - Hard freeze! Protect crops immediately.`
                    });
                } else if (node.temperature <= 2) {
                    alerts.soon.push({
                        icon: '‚ùÑÔ∏è',
                        title: 'Frost Warning',
                        text: `${node.node_id}: ${node.temperature.toFixed(1)}¬∞C - Frost likely within hours.`
                    });
                } else if (node.temperature <= 4) {
                    alerts.later.push({
                        icon: 'üå°Ô∏è',
                        title: 'Cool Conditions',
                        text: `${node.node_id}: ${node.temperature.toFixed(1)}¬∞C - Monitor overnight temperatures.`
                    });
                }

                // Fog alerts
                if (dewpointGap < 1) {
                    alerts.now.push({
                        icon: 'üå´Ô∏è',
                        title: 'FOG PRESENT',
                        text: `${node.node_id}: Dewpoint gap ${dewpointGap.toFixed(1)}¬∞C - Heavy fog. Visibility impaired.`
                    });
                } else if (dewpointGap < 2) {
                    alerts.soon.push({
                        icon: 'üå´Ô∏è',
                        title: 'Fog Forming',
                        text: `${node.node_id}: Dewpoint gap ${dewpointGap.toFixed(1)}¬∞C - Fog likely soon.`
                    });
                }

                // Battery alerts
                if (node.battery_voltage && node.battery_voltage < 3.3) {
                    alerts.now.push({
                        icon: 'üîã',
                        title: 'CRITICAL BATTERY',
                        text: `${node.node_id}: ${node.battery_voltage.toFixed(2)}V - Shutdown imminent!`
                    });
                } else if (node.battery_voltage && node.battery_voltage < 3.6) {
                    alerts.soon.push({
                        icon: 'üîã',
                        title: 'Low Battery',
                        text: `${node.node_id}: ${node.battery_voltage.toFixed(2)}V - Recharge needed soon.`
                    });
                }
            });

            // Offline nodes
            inactiveNodes.forEach(node => {
                alerts.now.push({
                    icon: 'üì°',
                    title: 'NODE OFFLINE',
                    text: `${node.node_id}: No data for ${Math.floor(node.seconds_since_update / 60)} minutes.`
                });
            });

            // Good conditions
            if (alerts.now.length === 0 && alerts.soon.length === 0 && activeNodes.length > 0) {
                const avgTemp = activeNodes.reduce((sum, n) => sum + n.temperature, 0) / activeNodes.length;
                if (avgTemp >= 5 && avgTemp <= 25) {
                    alerts.later.push({
                        icon: '‚úÖ',
                        title: 'Ideal Conditions',
                        text: `All systems healthy. Perfect weather for outdoor work.`
                    });
                }
            }

            return alerts;
        }

        function updateAlerts(nodes) {
            const alerts = analyzeAlerts(nodes);

            document.getElementById('now-count').textContent = alerts.now.length;
            document.getElementById('soon-count').textContent = alerts.soon.length;
            document.getElementById('later-count').textContent = alerts.later.length;

            ['now', 'soon', 'later'].forEach(category => {
                const items = document.getElementById(`${category}-items`);
                const summary = document.getElementById(`${category}-summary`);

                items.innerHTML = '';

                if (alerts[category].length === 0) {
                    summary.textContent = category === 'now' ? 'No critical alerts' :
                                         category === 'soon' ? 'No warnings' : 'All clear';
                } else {
                    summary.textContent = `${alerts[category].length} ${category === 'now' ? 'critical' : category === 'soon' ? 'warning' : 'info'} ${alerts[category].length === 1 ? 'alert' : 'alerts'}`;

                    alerts[category].forEach(alert => {
                        const item = document.createElement('div');
                        item.className = `alert-item ${category}`;
                        item.innerHTML = `
                            <div class="alert-icon">${alert.icon}</div>
                            <div class="alert-text">
                                <strong>${alert.title}</strong>
                                ${alert.text}
                            </div>
                        `;
                        items.appendChild(item);
                    });
                }
            });
        }

        // Populate node checkboxes
        function populateNodeCheckboxes() {
            const container = document.getElementById('node-checkboxes');
            container.innerHTML = '';

            const nodeColors = {
                'NODE_01': '#f59e0b',
                'NODE_02': '#3b82f6',
                'NODE_WIFI': '#10b981'
            };

            // Only show these nodes in the chart selector
            const allowedNodes = ['NODE_01', 'NODE_02', 'NODE_WIFI'];

            // Default checked nodes
            const defaultChecked = ['NODE_01', 'NODE_02'];

            currentNodes.filter(node => allowedNodes.includes(node.node_id)).forEach(node => {
                const checkbox = document.createElement('label');
                checkbox.style.cssText = 'display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 14px; color: #333;';

                const color = nodeColors[node.node_id] || '#999';
                const isChecked = defaultChecked.includes(node.node_id);

                checkbox.innerHTML = `
                    <input type="checkbox"
                           class="node-checkbox"
                           value="${node.node_id}"
                           ${isChecked ? 'checked' : ''}
                           onchange="updateCharts('${currentTimeRange}')"
                           style="cursor: pointer;">
                    <span style="display: inline-block; width: 12px; height: 12px; background: ${color}; border-radius: 2px;"></span>
                    <span>${node.node_id}</span>
                `;

                container.appendChild(checkbox);
            });
        }

        // Reset chart zoom
        function resetChartZoom() {
            if (tempChart) {
                tempChart.resetZoom();
            }
        }

        // Charts with Dewpoint
        async function updateCharts(timeRange) {
            currentTimeRange = timeRange;

            // Update active button if this was triggered by time selector
            if (event && event.target && event.target.classList.contains('time-btn')) {
                document.querySelectorAll('.time-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
            }

            // Get selected data type
            const dataTypeRadio = document.querySelector('input[name="dataType"]:checked');
            const dataType = dataTypeRadio ? dataTypeRadio.value : 'temperature';

            // Update chart title
            const titles = {
                'temperature': 'üìä Temperature & Dewpoint History',
                'humidity': 'üìä Humidity History',
                'pressure': 'üìä Pressure History'
            };
            document.getElementById('chart-title').textContent = titles[dataType] || titles['temperature'];

            try {
                const hours = timeRange === '1h' ? 1 : timeRange === '6h' ? 6 : timeRange === '3d' ? 72 : timeRange === '7d' ? 168 : 24;
                const response = await fetch(`${HISTORY_API_URL}?hours=${hours}`);
                const data = await response.json();

                // Get selected nodes from checkboxes
                const selectedNodes = Array.from(document.querySelectorAll('.node-checkbox:checked'))
                    .map(cb => cb.value);

                if (selectedNodes.length === 0) {
                    console.log('No nodes selected for chart');
                    return;
                }

                const ctx = document.getElementById('tempChart').getContext('2d');

                if (tempChart) tempChart.destroy();

                // Organize data by node
                const nodeData = {};
                data.readings.forEach(reading => {
                    if (!selectedNodes.includes(reading.node_id)) return;

                    if (!nodeData[reading.node_id]) {
                        nodeData[reading.node_id] = {
                            timestamps: [],
                            temperatures: [],
                            dewpoints: [],
                            humidity: [],
                            pressure: []
                        };
                    }

                    const dewpoint = reading.temperature - ((100 - reading.humidity) / 5);

                    nodeData[reading.node_id].timestamps.push(new Date(reading.timestamp));
                    nodeData[reading.node_id].temperatures.push(reading.temperature);
                    nodeData[reading.node_id].dewpoints.push(dewpoint);
                    nodeData[reading.node_id].humidity.push(reading.humidity);
                    nodeData[reading.node_id].pressure.push(reading.pressure);
                });

                const datasets = [];
                const nodeColors = {
                    'NODE_01': '#f59e0b',
                    'NODE_02': '#3b82f6',
                    'NODE_WIFI': '#10b981'
                };

                // Create datasets based on selected data type
                Object.keys(nodeData).forEach(nodeId => {
                    const color = nodeColors[nodeId] || '#999';

                    if (dataType === 'temperature') {
                        // Temperature line (solid)
                        datasets.push({
                            label: `${nodeId} Temp`,
                            data: nodeData[nodeId].timestamps.map((t, i) => ({
                                x: t,
                                y: nodeData[nodeId].temperatures[i]
                            })),
                            borderColor: color,
                            backgroundColor: color + '33',
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                            pointRadius: hours > 24 ? 0 : 1
                        });

                        // Dewpoint line (dashed)
                        datasets.push({
                            label: `${nodeId} Dewpoint`,
                            data: nodeData[nodeId].timestamps.map((t, i) => ({
                                x: t,
                                y: nodeData[nodeId].dewpoints[i]
                            })),
                            borderColor: color,
                            backgroundColor: 'transparent',
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: hours > 24 ? 0 : 1
                        });
                    } else if (dataType === 'humidity') {
                        datasets.push({
                            label: `${nodeId} Humidity`,
                            data: nodeData[nodeId].timestamps.map((t, i) => ({
                                x: t,
                                y: nodeData[nodeId].humidity[i]
                            })),
                            borderColor: color,
                            backgroundColor: color + '33',
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                            pointRadius: hours > 24 ? 0 : 1
                        });
                    } else if (dataType === 'pressure') {
                        datasets.push({
                            label: `${nodeId} Pressure`,
                            data: nodeData[nodeId].timestamps.map((t, i) => ({
                                x: t,
                                y: nodeData[nodeId].pressure[i]
                            })),
                            borderColor: color,
                            backgroundColor: color + '33',
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                            pointRadius: hours > 24 ? 0 : 1
                        });
                    }
                });

                tempChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets: datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: hours <= 1 ? 'minute' : hours <= 24 ? 'hour' : 'day' }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: dataType === 'temperature' ? 'Temperature (¬∞C)' :
                                          dataType === 'humidity' ? 'Humidity (%)' : 'Pressure (hPa)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const unit = dataType === 'temperature' ? '¬∞C' :
                                                     dataType === 'humidity' ? '%' : ' hPa';
                                        return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + unit;
                                    }
                                }
                            },
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: 'ctrl'
                                },
                                zoom: {
                                    wheel: {
                                        enabled: true,
                                        speed: 0.1
                                    },
                                    pinch: {
                                        enabled: true
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: { min: 'original', max: 'original' }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error updating charts:', error);
            }
        }

        // Node Cards
        // Store mini chart instances
        const miniCharts = {};

        function updateNodes(nodes) {
            const container = document.getElementById('nodes-container');
            container.innerHTML = '';

            // Only show main nodes
            const displayNodes = ['NODE_01', 'NODE_02', 'NODE_WIFI'];

            nodes.filter(n => displayNodes.includes(n.node_id)).forEach(node => {
                const isActive = node.seconds_since_update < INACTIVE_THRESHOLD;
                const nodeColors = {
                    'NODE_01': '#f59e0b',
                    'NODE_02': '#3b82f6',
                    'NODE_WIFI': '#10b981'
                };
                const color = nodeColors[node.node_id] || '#999';

                const card = document.createElement('div');
                card.className = 'node-card';
                card.innerHTML = `
                    <div class="node-header">
                        <div class="node-name">${node.node_id}</div>
                        <div class="node-status ${isActive ? 'status-active' : 'status-inactive'}">
                            ${isActive ? 'ACTIVE' : 'INACTIVE'}
                        </div>
                    </div>
                    <div class="reading">
                        <span class="reading-label">üå°Ô∏è Temperature</span>
                        <span class="reading-value temp">${node.temperature.toFixed(1)}¬∞C</span>
                    </div>
                    <div class="reading">
                        <span class="reading-label">üîΩ Pressure</span>
                        <span class="reading-value pressure">${node.pressure.toFixed(1)} hPa</span>
                    </div>
                    <div class="reading">
                        <span class="reading-label">üíß Humidity</span>
                        <span class="reading-value humidity">${node.humidity.toFixed(1)}%</span>
                    </div>
                    ${node.battery_voltage ? `
                    <div class="reading">
                        <span class="reading-label">üîã Battery</span>
                        <span class="reading-value">${node.battery_voltage.toFixed(2)}V (${node.battery_percent}%)</span>
                    </div>
                    ` : ''}
                    <div class="mini-chart-container" style="margin-top: 10px; height: 60px;">
                        <canvas id="mini-chart-${node.node_id}"></canvas>
                    </div>
                    <div class="timestamp">Last updated: ${node.last_update}</div>
                `;
                container.appendChild(card);

                // Create mini chart after card is added to DOM
                setTimeout(() => createMiniChart(node.node_id, color), 100);
            });
        }

        // Create mini sparkline chart for a node
        async function createMiniChart(nodeId, color) {
            try {
                const response = await fetch(`${HISTORY_API_URL}?hours=6&node_id=${nodeId}`);
                const data = await response.json();

                const canvas = document.getElementById(`mini-chart-${nodeId}`);
                if (!canvas) return;

                const ctx = canvas.getContext('2d');

                // Destroy existing chart if any
                if (miniCharts[nodeId]) {
                    miniCharts[nodeId].destroy();
                }

                const readings = data.readings.filter(r => r.node_id === nodeId);
                const chartData = readings.map(r => ({
                    x: new Date(r.timestamp),
                    y: r.temperature
                }));

                miniCharts[nodeId] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            data: chartData,
                            borderColor: color,
                            backgroundColor: color + '33',
                            tension: 0.4,
                            fill: true,
                            borderWidth: 2,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false }
                        },
                        scales: {
                            x: { display: false, type: 'time' },
                            y: { display: false }
                        },
                        interaction: { enabled: false },
                        animation: { duration: 0 }
                    }
                });
            } catch (error) {
                console.error(`Error creating mini chart for ${nodeId}:`, error);
            }
        }

        // Main update function
        async function updateDashboard() {
            console.log('Fetching data from:', API_URL);
            try {
                const response = await fetch(API_URL);
                console.log('Response status:', response.status);

                const data = await response.json();
                console.log('Data received:', data);

                currentNodes = data.nodes;
                console.log('Number of nodes:', currentNodes.length);

                currentNodes.sort((a, b) => a.node_id.localeCompare(b.node_id));

                const activeNodes = currentNodes.filter(n =>
                    n.seconds_since_update < INACTIVE_THRESHOLD &&
                    /^NODE_\d+$/.test(n.node_id)
                );
                console.log('Active nodes for barometer:', activeNodes.length);

                if (activeNodes.length > 0) {
                    const avgPressure = activeNodes.reduce((sum, n) => sum + n.pressure, 0) / activeNodes.length;
                    console.log('Average pressure:', avgPressure);
                    updateBarometer(avgPressure);
                }

                console.log('Updating map markers...');
                updateMapMarkers(currentNodes);

                console.log('Updating alerts...');
                updateAlerts(currentNodes);

                console.log('Updating node cards...');
                updateNodes(currentNodes);

                console.log('Updating average readings...');
                updateAverageReadings(currentNodes);

                console.log('Dashboard update complete!');
            } catch (error) {
                console.error('ERROR updating dashboard:', error);
                console.error('Error details:', error.message, error.stack);
            }
        }

        // Update average readings for NODE_01 and NODE_02
        function updateAverageReadings(nodes) {
            const node01 = nodes.find(n => n.node_id === 'NODE_01');
            const node02 = nodes.find(n => n.node_id === 'NODE_02');

            if (node01 && node02 &&
                node01.seconds_since_update < INACTIVE_THRESHOLD &&
                node02.seconds_since_update < INACTIVE_THRESHOLD) {

                const avgTemp = (node01.temperature + node02.temperature) / 2;
                const avgHumidity = (node01.humidity + node02.humidity) / 2;
                const avgPressure = (node01.pressure + node02.pressure) / 2;

                document.getElementById('avg-temp').textContent = avgTemp.toFixed(1) + '¬∞C';
                document.getElementById('avg-humidity').textContent = avgHumidity.toFixed(1) + '%';
                document.getElementById('avg-pressure').textContent = avgPressure.toFixed(1) + ' hPa';

                console.log('Average readings updated:', { avgTemp, avgHumidity, avgPressure });
            } else {
                document.getElementById('avg-temp').textContent = '--¬∞C';
                document.getElementById('avg-humidity').textContent = '--%';
                document.getElementById('avg-pressure').textContent = '-- hPa';
                console.log('Average readings unavailable (nodes offline or missing)');
            }
        }

        // Initialize - Wait for DOM and scripts to load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('=== Dashboard initializing ===');
            console.log('Leaflet available?', typeof L !== 'undefined');
            console.log('Chart available?', typeof Chart !== 'undefined');

            try {
                console.log('Initializing barometer...');
                initBarometer();
                console.log('Barometer initialized');
            } catch (e) {
                console.error('Barometer init failed:', e);
            }

            // Wait a tiny bit for Leaflet to be ready
            setTimeout(() => {
                try {
                    console.log('Initializing map...');
                    initMap();
                    console.log('Map initialized');

                    console.log('Starting initial dashboard update...');
                    updateDashboard().then(() => {
                        // Populate checkboxes after first data load
                        console.log('Populating node checkboxes...');
                        populateNodeCheckboxes();

                        // Load charts with default selection
                        setTimeout(() => {
                            console.log('Loading charts...');
                            updateCharts('24h');
                        }, 500);
                    });

                    console.log('Setting up refresh interval...');
                    setInterval(updateDashboard, REFRESH_INTERVAL);
                } catch (e) {
                    console.error('Initialization failed:', e);
                }
            }, 100);
        });
    </script>
</body>
</html>
